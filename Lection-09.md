# Лекция 9

## Протоколы динамической маршрутизации в ip-сетях

### Общие сведения

* Задача: построение, отслеживание и перестроение маршрутных таблиц
* Классификация
  * Масштаб:
    * Внутридоменные (внутри организаций):
      * RIP
      * OSPF
    * Внешние:
      * EGP
  * Механизмы построения маршрута:
    * Через Distance Vector (DV)
      * Получаем от соседа DV - словарик подсеть -> метрика
    * Link state protocol (OSPF)
      * Знаем, как устроена сетка, имеем графовое представление сети. Используем Дейкстру для обхода сети и поиска лучшего маршрута
    * На базе политик и правил
      * Если есть внешние факторы, которые могут повлиять на передачу трафика

## RIP (Routing Information Protocol)

* В качестве транспорта использует UDP
* Возможен broadcast; в сетях, где нет широковещания возможен unicast; в RIP v2 возможен multicast (224.0.0.9)
* По инкапсуляции - протокол прикладного уровня, по функционалу - протокол сетевого уровня

### Стандарты

* RIP v1: RFC 1058. Классовая адресация. *Не применяется*.
* RIP v2: RFC 2453
* RIP v2 + Cryptographic Authentication: RFC 4822

### RIP v2 vs. RIP v1

* Минусы RIP v1 по сравнению с RIP v2:
  * Классовая адресация (не можем двигать маску)
  * Нет информации о следующем узле
  * Нет поддержки автономной системы
  * Нет multicast
  * Нет защиты
* Плюсы RIP v2:
  * Простота
  * Небольшие затраты пропускной способности
  * Взаимная аутентификация маршрутизаторов (ситуация, когда 2 маршрутизатора обмениваются шифром и проверяют, могут ли они друг другу доверять)
* Минусы RIP v2:
  * Внутридоменная маршрутизация
  * Диаметр сети не больше 15 при базовой стоимости узла равной 1
  * "Счет до бесконечности" для решения нештатных ситуаций
  * Фиксированные метрики

### Алгоритм вектора расстояний

* Распределенный вариант алгоритма Беллмана
* Обмен данными только с соседями (broadcast или multicast)
* Минимизируем метрику

### Как решаются задачи маршрутизации?

* Периодически рассылаем соседям информацию о своих узлах
* При получении сообщения:
  * Если пришел маршрут до новой сети, то добавляем его в таблицу
  * Если пришел более дешевый маршрут до известной сети, то обновляем метрику
  * **!!!** Если от соседа, через которого раньше был самый выгодный маршрут до некоторой сети, пришел более дорогой маршрут до этой сети, то обновляем метрику

> [!NOTE]
> Рассылка происходит раз в 30 секунд в базовой версии, в улучшенной есть обновление по триггеру. Если маршрутизатор не отвечает 180 секунд, то считаем, что маршрут через него не корректен.
> Раз в 120 секунд производится сборка мусора (удаление некорректных маршрутов). Задержка при триггере составляет от 1 до 5 секунд.
> 
> Также можем сообщить соседям, что через нас больше не посылать, разослав всем сообщение с метрикой, превышающей максимальную (т.е. равной 16).

* Для понимания рассмотрим пример:
![сети (1)](https://github.com/AliakseiSuvorau/networks/assets/98915109/56d3708c-6260-446d-8ad1-a0b42869a2d6)

![export](https://github.com/AliakseiSuvorau/networks/assets/98915109/b00af2ae-9669-404f-8b80-417be7c8227a)

### Счет до бесконечности

* Процесс рассылки маршратизаторами сообщений для исправления нештатных ситуаций
* Для понимания работы рассмотрим перестройку таблицы маршрутов до сети D после того, как отвалилось соединение B-D:
![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/473e7a0d-7a81-4fe7-beab-cfb1e76c43cc)

* **Разделение горизонта** - решение проблемы счета до бесконечности в локальном сегменте
  * Маршруты, изученные от соседа, назад соседу не передаются

* **Отравление отправителя** - улучшение разделения горизонта (используется совместно с ним)
  * Соседу, от которого этот маршрут и был получен, возвращаем его с расстоянием 16
  * Плюс:
    * Сразу обновляем маршрут
  * Минусы:
    * Увеличивается количество передаваемой информации
    * Все еще решаем проблему только в локальном сегменте

* Обновления по событиям
  * Посылаем сообщение сразу же когда меняется таблица
  * Плюс:
    * Сокращаем время ожидания

### Форматы пакетов

#### RIP

* 8 бит - команда (1 - запрос, 2 - ответ)
* 8 бит - версия (1 или 2)
* 16 бит - нули (выравнивание) или домен маршрутизации
* RIP Entry (маршрутные записи)

#### RIP v1 (Вид записей, после заголовка общего вида длиной 32 бита)

* 16 бит - address family id (определяет, какой протокол был использован. Для IPv4 - 2)
* 16 бит - нули (выравнивание)
* 32 бит - ip-адрес
* 64 бита - нули
* 32 бита - метрика

#### RIP v2 (Вид записей, после заголовка общего вида длиной 32 бита)

* 16 бит - address family id
* 16 бит - route tag
* 32 бит - ip-адрес
* 32 бита - маска подсети
* 32 бита - next hop (аналог icmp-редиректа)
* 32 бита - метрика

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/4e5e4623-5d8f-44d1-bb22-3c252b207317)

> [!NOTE]
> Поле "Домен маршрутизации" используется вместе с полем "Следующий переход" для позволения нескольким автономным системам разделять одну физическую среду передачи
> (делим сеть на подсети).
>
> Route tag используется для указания некоторой дополнительной информации о маршруте.

> [!NOTE]
> После заголовка идут записи о векторе расстояний. Если используется алгоритм аутентификации, то в качестве первой записи будет стоять аутентификация `0xFFFF`. Если же используется алгоритм криптографической аутентификации,
> то в качестве первой и последней записей будут стоять строки, связанные с этим алгоритмом.

> [!NOTE]
> Когда только подключаемся к сети, можем послать запрос с просьбой рассказать все о структуре сети, что знают наши соседи. Это будет RIP-запрос в сеть с адресом 0 и метрикой 16.

#### Аутентификация

* В RIP v2, вместо ip-адреса ставится `0xFFFF`, вместо маски подсети - тип аутентификации
* Борьба с подключением в сети ненастроенных маршрутизаторов и их участием в построении маршрутов
* Обновляем таблицу маршрутизации только если сосед дал правильный пароль
* Типы:
  * 2 - пароль в открытом виде (не дает защиты от атаки, но защищает от неправильно сконфигурированных устройств)
  * 3 - криптографическая хеш-функция

**Заголовок RIP v2 пакета с криптографической аутентификацией**:
* 8 бит - команда
* 8 бит - версия
* 16 бит - домен маршрутизации
* 16 бит - `0xFFFF`
* 16 бит - тип аутентификации, `0x0003`
* 16 бит - длина пакета
* 8 бит - ключ (м.б. уникальный для работы с разными соседями)
* 8 бит - длина аутентификации (т.к. они м.б. переменной длины)
* 32 бита - sequence number (неубывает, для того, чтобы распознать, актуальная ли информация передана в этой таблице, см. замечание далее)
* 64 бита - нули (зарезервировано)
* Данные
* 16 бит - `0xFFFF`
* 16 бит - `0x0001`
* Переменная длина - информация для аутентификации

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/9b67ac00-ebbe-45bb-a45c-1e712c5c09eb)

> [!NOTE]
> Поле sequence number используется для следующей ситуации: представим, что хакер скопипастил себе полностью валидную таблицу со всеми маршрутами, ключом и т.д. Если он захочет нам подпортить жизнь и позже,
> когда эта таблица будет уже неактуальна, подкинуть ее в сеть, то у него ничего не получится, так как в старой версии таблицы будет меньший sequence number, чем в актуальной, а изменить он его не сможет,
> т.к. тогда придется пересчитывать хеш, для чего ему нужна хеш-функция.

> [!NOTE]
> В IPv6 есть аналог RIP - RIPng.

## OSPF (Open Shortest Path First)

* Каждый маршрутизатор имеет (почти) полное представление о сети в виде графа
* Построение маршрута Дейкстрой
* Плюсы:
  * Быстрая реакция на изменения топологии
  * Баланс нагрузки
  * Взаимная аутентификация узлов
  * Импорт внешних маршрутов

Введем некоторые пормальные определения:

* **Автономная система** - группа маршрутизаторов, обменивающихся маршрутной информацией с использованием одного общего протокола
* **Соседние маршрутизаторы** - устройства, имеющие интерфейс в одной сети
* **Смежность** - вид отношений между соседними маршрутизаторами с целью обмена маршрутной информацией (Не все пары соседних маршрутизаторов)

* Части протокола OSPF
  * Flooding - часть OSPF, при помощи которой распространяется информация и синхронизируется link-state database
  * Hello Protocol - часть OSPF для установки и поддержания соседских отношений

* LSDB - графовая БД, позволяющая представить сеть в виде взвешенного ориентированного графа
  * Узлы - роутеры и сети
  * Дуги - связи между роутерами (point-to-point) и между роутером и сетью (из сети в роутер - ничего не весит)

> [!NOTE]
> Для каждого маршрутизатора строится своя матрица смежности, по экземпляру на каждую область.

### Зонирование на области

* Для того, чтобы LSDB были компактней
* Каждая область - своя LSDB
* Из одной области в другую только суммарные маршруты

> [!NOTE]
> Фактически делимся векторами расстояний между областями.

* id области (4 октета, уникальный в рамках одной автономной системы)
* id маршрутизатора (уникальный в автономной системе) - обычно min или max среди всех интерфейсов роутера. Используется в БД, т.к. ip могут меняться

#### Типы маршпутизаторов относительно областей

* Internal
* ASBR (Autonomos System Boundary Router)
* ABR (Area Border Router)
* Backborn routers

#### Типы областей

* Backborn (магистральная, 0.0.0.0) - выбирается ручками, с ней должны быть соединены все остальные области
* Area - все остальные
* Stub area - не принимаем информацию о внешних по отношению к автономной системе маршрутах (тут не м.б. граничегого роутера ASBR, если он не ABR)
* No-so-stubby area - как Stub area, но в области м.б. ASBR
* Totally-stubby area - не является стандартной, не принимает никаких маршрутов из других областей

> [!NOTE]
> Если не хотим соединять все области с магистральной напрямую, то можем использовать виртуальные каналы.
> Это логические каналы, которые соединяют нашу область с магистральной.

### Работа OSPF

* Выбираются 2 роутера: designated (DR) и back-up designated (BDR). Остальные роутеры не будут иметь ролей. BDR - на случай, если DR сломается
    * DR - первый активный маршрутизатор
    * BDR - второй активный маршрутизатор
    * Если сломается BDR, то будет выбран в качестве нового BDR тот, у кого наибольший приоритет стать BDR. При равенстве приоритетов выбираем с большим ID
    * Если у роутера приоритет 0, то мы не можем его выбрать в качестве DR или BDR
* Маршрутизаторы обмениваются информацией только если между ними установлены соседские отношения
* Соседские отношения для уменьшения количества трафика устанавливаются только между DR и всеми остальными
* Роутер сообщает об изменениях только DR, а DR - всем остальных

> [!IMPORTANT]
> Роли (DR или BDR) относятся к интерфейсам и один и тот же роутер в разных сетях может иметь разные роли.

### Установление соседских отношений

* Сеть точка-точка
* Сеть - виртуальный канал
* Мы DR
* Сосед DR
* Мы BDR
* Сосед BDR
* Интерфейсы - в одной подсети
* Совпадают типы сетей
* Интерфейсы роутеров принадлежат одной области
* Совпадает тип области
* Роутеры прошли взаимную аутентификацию, если она включена
* Одинаковые временные параметры

### Состояния соседских отношений

* Установление:
  * Down (роутер ни от кого не получал hello)
  * Attempt (посылка потенциальному соседу)
  * Init (роутер получил hello от соседа и добавил его в список)
  * Two-Way (и мы увидели соседа, и сосед нас увидел, то есть роутер получил адресный ответ на свой hello)
* Синхронизация LSDB
  * ExStart (начало процесса синхронизации LSDB) - маршрутизатор с большим ID становится master'ом, а его сосед - slave'ом
  * Exchange - передается некоторая заголовочная информация, позволяющая понять, есть ли у нас эти записи и, если есть, то у кого они более актуальны
  * Loading - если master имеет более новую информацию, то:
    * slave ее запрашивает с помощью LSR
    * master передает ее с помощью LSU
    * slave подтверждает ее с помощью LSAck
  * Full - соседи полностью синхронизированы

> [!NOTE]
> Виды пакетов:
> * Hello
> * LSDB description (LSDD)
> * Link State Request (LSR)
> * Link State Update (LSU)
> * Link State Acknowledgment (LSAck)

### Формат hello-пакета

#### Заголовок

* 8 бит - версия
* 8 бит - тип
* 16 бит - длина пакета
* 32 бита - id роутера
* 32 бита - area id
* 16 бит - checksum
* 16 бит - authentication type
* 64 бита - authentication

#### Hello-пакет

* 32 бита - маска сети
* 16 бит - hello-interval
* 8 бит - опции
* 8 бит - приоритет
* 32 бита - Router Dead Interval
* 32 бита - DR
* 32 бита - BDR
* 32 бита - сосед
* ...

### Локальный flooding

* Если какой-то роутер заметил изменения сети
* Обнаруживший роутер генерирует (Link State Advertisement) LSA и рассылает обновления через все интерфейсы
* Соседи сравнивают LSA со своими LSDB и в своем сегменте дальше рассылают на все интерфейсы кроме того, с которого пришло
* Посылается подтверждение исходному роутеру

### Глобальный flooding

* Роутер рассылает LSU (224.0.0.6)
* DR и BDR обновляют свои LSDB
* DR рассылает LSU в своем сегменте (224.0.0.5)
* Все маршуртизаторы сегмента обновляют свои LSDB
* Процесс повторяется в других сегментах

### Основные типы записей LSA

* Router Links (Type 1)
  * Состояние каналов маршрутизатора
  * В пределах одной области
  * Рассылается всеми маршрутизаторами
* Network Links (Type 2)
  * Состояние каналов присоединенной сети
  * В пределах одной области
  * Рассылаются DR
* Summary Links (Type 3)
  * Суммарное состояние каналов сети
  * Рассылаются ABR
  * Содержит маршруты к сетям вне области, не описывает маршруты внути автономной системы
* Autonomos System Summary Links (Type 4)
  * Состояние каналов ABSR
  * Рассылается ABR
  * Содершит информацию о наличии в области ABSR
* Autonomos System External Links (Type 5)
  * Состояние внешних каналов автономной системы
  * Рассылается ABSR внутри автономной системы
  * Содержаит внешние по отношению к автономной системе маршруты, в т.ч. маршруты по умолчанию

### Итог

* Плюсы:
  * топология без колец маршрутизации
  * быстро (есть триггеры и инкрементные обновления (изменяем только те записи, что в LSA, а не всю БД)
  * можно проектировать иерархические сети
* Минусы:
  * сложный (по сравнению с DV)
  * требовательный к аппаратному обеспечению

* Альтернативы:
  * IS-IS
  * EIGRP
