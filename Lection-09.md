# Лекция 9

## Протоколы динамической маршрутизации в ip-сетях

### Общие сведения

* Задача: построение, отслеживание и перестроение маршрутных таблиц
* Классификация
  * Масштаб:
    * Внутридоменные (внутри организаций):
      * RIP
      * OSPF
    * Внешние:
      * EGP
  * Механизмы построения маршрута:
    * Через Distance Vector (DV)
      * Получаем от соседа DV - словарик подсеть -> метрика
    * Link state protocol (OSPF)
      * Знаем, как устроена сетка, имеем графовое представление сети. Используем Дейкстру для обхода сети и поиска лучшего маршрута
    * На базе политик и правил
      * Если есть внешние факторы, которые могут повлиять на передачу трафика

* В качестве транспорта использует UDP
* Возможен broadcast; в сетях, где нет широковещания возможен unicast; в RIP v2 возможен multicast (224.0.0.9)
* По инкапсуляции - протокол прикладного уровня, по функционалу - протокол сетевого уровня

## RIP (Routing Information Protocol)

### Стандарты

* RIP v1: RFC 1058. Классовая адресация. *Не применяется*.
* RIP v2: RFC 2453
* RIP v2 + Cryptographic Authrntication: RFC 4822

### RIP v2 vs. RIP v1

* Минусы RIP v1 по сравнению с RIP v2:
  * Классовая адресация (не можем двигать маску)
  * Нет информации о следующем узле
  * Нет поддержки автономной системы
  * Нет multicast
  * Нет защиты
* Плюсы RIP v2:
  * Простота
  * Небольшие затраты пропускной способности
  * Взаимная аутентификация маршрутизаторов (ситуация, когда 2 маршрутизатора обмениваются шифром и проверяют, могут ли они друг другу доверять)
* Минусы RIP v2:
  * Внутридоменная маршрутизация
  * Диаметр сети не больше 15 при базовой стоимости узла равной 1
  * "Счет до бесконечности" для решения нештатных ситуаций
  * Фиксированные метрики

### Алгоритм вектора расстояний

* Распределенный вариант алгоритма Беллмана
* Обмен данными только с соседями (broadcast или multicast)
* Минимизируем метрику

### Как решаются задачи маршрутизации?

* Периодически рассылаем соседям информацию о своих узлах
* При получении сообщения:
  * Если пришел маршрут до новой сети, то добавляем его в таблицу
  * Если пришел более дешевый маршрут до известной сети, то обновляем метрику
  * **!!!** Если от соседа, через которого раньше был самый выгодный маршрут до некоторой сети, пришел более дорогой маршрут до этой сети, то обновляем метрику

> [!NOTE]
> Рассылка происходит раз в 30 секунд в базовой версии, в улучшенной есть обновление по триггеру. Если маршрутизатор не отвечает 180 секунд, то считаем, что маршрут через него не корректен.
> Раз в 120 секунд производится сборка мусора (удаление некорректных маршрутов). Задержка при триггере составляет от 1 до 5 секунд.
> 
> Также можем сообщить соседям, что через нас больше не посылать, разослав всем сообщение с метрикой, превышающей максимальную (т.е. равной 16).

* Для понимания рассмотрим пример:
![сети (1)](https://github.com/AliakseiSuvorau/networks/assets/98915109/56d3708c-6260-446d-8ad1-a0b42869a2d6)

![export](https://github.com/AliakseiSuvorau/networks/assets/98915109/b00af2ae-9669-404f-8b80-417be7c8227a)

### Счет до бесконечности

* Процесс рассылки маршратизаторами сообщений для исправления нештатных ситуаций
* Для понимания работы рассмотрим перестройку таблицы маршрутов до сети D после того, как отвалилось соединение B-D:
![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/473e7a0d-7a81-4fe7-beab-cfb1e76c43cc)

* **Разделение горизонта** - решение проблемы счета до бесконечности в локальном сегменте
  * Маршруты, изученные от соседа, назад соседу не передаются

* **Отравление отправителя** - улучшение разделения горизонта (используется совместно с ним)
  * Соседу, от которого этот маршрут и был получен, возвращаем его с расстоянием 16
  * Плюс:
    * Сразу обновляем маршрут
  * Минусы:
    * Увеличивается количество передаваемой информации
    * Все еще решаем проблему только в локальном сегменте

* Обновления по событиям
  * Посылаем сообщение сразу же когда меняется таблица
  * Плюс:
    * Сокращаем время ожидания

### Форматы пакетов

#### RIP

* 8 бит - команда (1 - запрос, 2 - ответ)
* 8 бит - версия (1 или 2)
* 16 бит - нули (выравнивание)
* (от 1 до 25 бит) RIP Entry

#### RIP v1

* 16 бит - address family id
* 16 бит - нули (выравнивание)
* 32 бит - ip-адрес
* 64 бита - нули
* 32 бита - метрика

#### RIP v2

* 16 бит - address family id
* 16 бит - идентификатор маршрута (из какого домена маршрутизации пришел этот маршрут)
* 32 бит - ip-адрес
* 32 бита - маска подсети
* 32 бита - next hop (аналог icmp-редиректа)
* 32 бита - метрика

> [!NOTE]
> После заголовка идут записи о векторе расстояний. Если используется алгоритм аутентификации, то в качестве первой записи будет стоять аутентификация `0xFFFF`. Если же используется алгоритм криптографической аутентификации,
> то в качестве первой и последней записей будут стоять строки, связанные с этим алгоритмом.

> [!NOTE]
> Когда только подключаемся к сети, можем послать запрос с просьбой рассказать все о структуре сети, что знают наши соседи. Это будет RIP-запрос в сеть с адресом 0 и метрикой 16.

#### Аутентификация

* В RIP v2, вместо ip-адреса ставится `0xFFFF`, вместо маски подсети - тип аутентификации
* Борьба с подключением в сети ненастроенных маршрутизаторов и их участием в построении маршрутов
* Обновляем таблицу маршрутизации только если сосед дал правильный пароль
* Типы:
  * 2 - пароль в открытом виде (не дает защиты от атаки, но защищает от неправильно сконфигурированных устройств)
  * 3 - криптографическая хеш-функция

**Заголовок RIP v2 пакета с криптографической аутентификацией**:
* 8 бит - команда (1 - запрос, 2 - ответ)
* 8 бит - версия (1 или 2)
* 16 бит - идентификатор маршрута
* 16 бит - `0xFFFF`
* 16 бит - тип аутентификации, `0x0003`
* 16 бит - длина пакета
* 8 бит - ключ (м.б. уникальный для работы с разными соседями)
* 8 бит - длина аутентификации (т.к. они м.б. переменной длины)
* 32 бита - sequence number (неубывает, для того, чтобы распознать, актуальная ли информация передана в этой таблице, см. замечание далее)
* 64 бита - нули (зарезервировано)
* Данные
* 16 бит - `0xFFFF`
* 16 бит - `0x0001`
* Переменная длина - информация для аутентификации

> [!NOTE]
> Поле sequence number используется для следующей ситуации: представим, что хакер скопипастил себе полностью валидную таблицу со всеми маршрутами, ключом и т.д. Если он захочет нам подпортить жизнь и позже,
> когда эта таблица будет уже неактуальна, подкинуть ее в сеть, то у него ничего не получится, так как в старой версии таблицы будет меньший sequence number, чем в актуальной, а изменить он его не сможет,
> т.к. тогда придется пересчитывать хеш, для чего ему нужна хеш-функция.

> [!NOTE]
> В IPv6 есть аналог RIP - RIPng.

## OSPF (Open Shortest Path First)
