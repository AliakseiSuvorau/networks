# Лекция 8

## Содержание
* [IPv4: Сабнетинг и супернетинг](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#сабнетинг-и-супернетинг)
* [ICMPv4](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#icmpv4)
  * Общая информация
  * Заголовок icmp
  * Основные типы icmp-сообщений
* [UDP](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#udp)
  * Общая информация
  * Задачи
  * Формат пакета
* [UDP-Lite](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#udp-lite)
  * Формат заголовка
  * UDP Guidelines
* [Дейтаграммные транспорты](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#дейтаграммые-транспорты)
* [Multicasting](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#multicasting)
* [IGMP](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#igmp)
  * Задачи
  * Стандарты
  * Алгоритм работы
* [Коммутаторы и snooping](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-08.md#коммутаторы-и-snooping)
  * IGMP Proxy

### Сабнетинг и супернетинг
* Сабнетинг - разделение доступного сетевого диапазона путем сдвига маски сети
  
> [!TIP]
> **Пример сабнетинга**:
>
> Пусть имеем подсеть `192.168.11.0/24`. Хоти сделать подсети A, B, и C на 100, 50 и 25 хостов соответственно.
> Какие будут маски этих подсетей? Какие минимальный (FA) и максимальный (LA) адреса будут в этих подсетях? Как будет выглядеть broadcast-адрес (BA) в этих подсетях?
>
> *Решение*:
>
> Для начала посчитаем количество битов, нужное для таго, чтобы выдать всем устройствам подсети адрес: $\lceil\log_2N\rceil$, где $N$ - количество хостов.
> Далее вспомним, что все нули - это неизвестный адрес, а все единицы - это broadcast-адрес. Тогда ответим на вопросы:
> 1) * A: `192.168.11.0/25`
>    * FA: `192.168.11.1`
>    * LA: `192.168.11.126`
>    * BA: `192.168.11.127`
> 2) * B: `192.168.11.128/26`
>    * FA: `192.168.11.129`
>    * LA: `192.168.11.190`
>    * BA: `192.168.11.191`
> 3) * C: `192.168.11.192/27`
>    * FA: `192.168.11.193`
>    * LA: `192.168.11.222`
>    * BA: `192.168.11.223`

* Супернетинг - объединение доступного сетевого диапазона путем сдвига маски сети

> [!TIP]
> **Пример супернетинга**:
>
> Пусть имеем подсеть с адресом `192.168.11.0/24`. Хотим сдвинуть маску на 1 бит. Получим `192.168.10.0/23`.
--------------------------------------------------------------------------------
## ICMPv4

### Общая информация

* *Цель* - информирование о проблемах (ошибках) с ip-дейтаграммами, а также диагностика.

> [!NOTE]
> Если возникает ошибка при доставке icmp-сообщения, то icmp-сообщение, говорящее об этой ошибке, не посылается (за исключением некоторых случаев).

* Инкапсулировано в IP под номером 1

### Заголовок icmp

* Тип icmp-сообщения (1 октет)
* Код icmp-сообщения (1 октет)
* Контрольная сумма (2 октета) - подсчитывается как в ip
* Данные

### Основные типы icmp-сообщений

#### Destination unreachable - 3
* Коды
  * 0 - net unreachable
  * 1 - host unreachable
  * 2 - protocol unreachable (к примеру, запихиваем протокол транспортного уровня хосту, который не умеет его обрабатывать)
  * 3 - port unreachable (послали сообщение на порт, который никто не слушает. Посылается хостом)
  * 4 - fragmentation needed and DF set
  * 5 - source route failed (в современных сетях не используется)

> [!NOTE]
> Код 3 используется из основных протоколов только в UDP.

> [!NOTE]
> Файерволы могут не посылать сообщения с кодом 3, так как это уменьшает количество портов для атаки.

* Данные
  * Неиспользуемые 32 бита
  * ip-заголовок + 8 октет не доставленной дейтаграммы

#### Time exceeded - 11
* Коды
  * 0 - ttl exceeded in transit
  * 1 - fragment reassembly time exceeded (время ожидания фрагмента дейтаграммы, который не дошел)

* Данные
  * Неиспользуемые 32 бита
  * ip-заголовок + 8 октет не доставленной дейтаграммы

#### Redirect - 5
* Посылается роутером, если он знает более выгодный маршрут
* **Пример**: Имеем хост H и 2 роутера R1 и R2, подключенных к одной LAN. Н хочет послать сообщение R2 и отправляет его R1. Тогда R1 пошлет H icmp-сообщение о том, что можно послать сразу на R1.
* Коды
  * 0 - redirect datagrams for the network
  * 1 - redirect datagrams for the host
  * 2 - redirect datagrams for the type of service and network
  * 3 - redirect datagrams for the type of service and host

> [!NOTE]
> При помощи этого механизма можно перенаправить трафик на прослушивающее устройство, поэтому в современных сетях мы не верим этим сообщениям.

* Данные
  * ip-адреса шлюза, через который предпостительнее доставить дейтаграмму (32 бита)
  * ip-заголовок + 8 октет не доставленной дейтаграммы

#### Echo запросы (8) и Echo ответы (0)
* Код - 0
* Данные
  * Идентификатор - для идентификации соответствия запросов ответам
  * Номер последовательности - увеличиваем для каждого следующего запроса
  * Сами данные
    * Произвольная последовательность октетов, определенных тем, кто отправляет запрос
    * В ответе эта последовательность должна быть продублирована
--------------------------------------------------------
 ## UDP

 ### Общая информация

 * User Datagram Protocol
 * Самый простой протокол
 * Базовый стандарт - RFC768 (август 1980)

### Задачи

* Реализация дейтаграммного режима передачи в сетях с пакетной адресацией
* Нижележащий протокол - ip
* Ориентирован на транзакционную модель взаимодействия (т.е. логика взаимодействия тут не реализована. За нее отвечают вышележащие протоколы)
* **Не** гарантирует:
  * Доставку пакетов
  * Защиту от дубликатов
  * Борьбу с перегрузками

> [!NOTE]
> Когда мы говорим об ip-протоколах, то используем термин дейтаграммы, о udp-протоколах - пользовательские дейтаграммы, о tcp-протоколах - сегменты, об Ethernet - кадр+преамбула+... . Пакет - более общий термин.

### Формат пакета

* Порт источника ( 16 бит)
* Порт приемника (16 бит)
* Длина (16 бит)
* Контрольная сумма (16 бит)
* Данные

#### Порт

* Определяет некоторое сетевое соединение
* Назначаемые
  * Системные: 0 - 1023
  * Пользовательские: 1024 - 49151
* Динамические: 49152 - 65535

> [!NOTE]
> * Порт 0 нельзя назначать
> * Граничные порты назначать не рекомендуется, но и не запрещается
> * Порт 80 - http (тут находится web-сервер. Он один, но на нем может работать несколько web-приложений)
> * Порт 53 - DNS

* Назначаемые порты:
  * Назначенные - закрепленные за каким-то широко распространенным сервисом
  * Неназначенные - доступные для назначения
  * Зарезервированные (0, 1023, 1024, ...)

#### Длина заголовка

* Общий размер дейтаграммы в байтах
* Минимальный - 8
* Максимальный - $2^{16}-1=65527$, но на деле из этой цифры еще вычитается длина ip-заголовка, т.е. 65507

#### Контрольная сумма

* Вычисляется по псевдозаголовку, загловку UDP и пользовательским данным
* Алгоритм:
  * Суммируем 16-битные числа (если надо - дополняем нулями) с переносом в младшие разряды
  * Берем обратный код (дополнение каждого бита до 1)
* Если равна 0, то считается, что контрольная сумма не вычислялась
* Псевдозаголовок
  * Источник (32 бита)
  * Получатель (32 бита)
  * Нули (8 битов)
  * Протокол (8 битов)
  * Длина UDP (16 битов)

> [!NOTE]
> Псевдозаголовок нигде не передается и нигде не хранится. Он просто создается на месте и используется при подсчете суммы.

## UDP-Lite

* Стандарт: RFC 3828, июль 2004
* Цель: реализация транспорта для приложений, которые не критичны к искажениям данных
* Номер протокола - 136

### Формат заголовка

* Адрес источника (16 бит)
* Адрес получателя (16 бит)
* Checksum coverage (16 бит) - укахывает, какие данные защищены контрольной суммой, в октетах. Минимальное значение - 8 (длина заголовка)
* Checksum (16 бит). Алгоритм подсчета - как в UDP
* Данные

### [UDP Guidelines](https://datatracker.ietf.org/doc/html/rfc8085)

* Описание набора правил и соглашений для использования UDP
* Задачи:
  * Борьба с перегрузками и фрагментацией
  * Обеспечение надежности доставки
  * Контрольная сумма
  * Использование нескольких портов

## Дейтаграммые транспорты

* Протоколы транспортного уровня
  * TCP
  * UDP
  * SCTP
  * DCCP
* Протоколы поверх транспортного уровня (содержатся внутри UDP)
  * SCTP/UDP
  * DCCP/UDP
  * QUIC/UDP
* Непосредственная пересылка данных поверх ip
  * OSPF
-------------------------------------------------
## Multicasting
**Вопрос**: Как формировать multicast-адресацию на уровне mac-адресов?
* Фиксируем первые 24 бита из mac-адреса (01-00-5Е)
* 1 бит выставлен в 0 (ip multicast address) или в 1 (зарезервирован)
* Последние 23 бита - это младшие 23 бита из ip-адреса

#### Групповые адреса на разных уровнях
  * В IPv4 - класс D (начинается с 1110)
  * На канальном уровне - первые 24 бита - organization unique identifier
  * На каждый mac-адрес приходится 32 ip-адреса

Нужно что-то, что будет сообщать роутеру, что в таком-то LAN'е есть кто-то, кто хочет получать multicast-сообщения, в каком-то другом таких устройств нет.
Эту роль выполняет протокол IGMP.

## IGMP

### Задачи

* Хосты сообщают роутеру о членстве в группе
* Маршрутизатор опрашивает хосты о членстве в группе

### Стандарты

* IGMPv1(1989) - RFC1112. Нельзя покинуть группу, отказ по истечении timeout'а. *Устаревший*.
* IGMPv2(1997) - RFC2236. *Наиболее часто используемый*.
* IGMPv3(2002) - RFC3376. Появилась возможность указывать, от кого хотим получать multicast-трафик. *Современный*.

### Алгоритм работы

* Роутер с помощью multicast-сообщения опрашивает все хосты в локальной сети (224.0.0.1), есть ли желающие получать хоть какой-то multicast-трафик
  * Если в сети несколько маршрутизаторов, то опрашивать будет только один, чтобы не было огромного количесвта сообщений. Это маршрутизатор с наименьшим ip-адресом.
    Он называется  Querier.
  * Если одному роутеру приходит опрос от другого роутера с меньшим ip-адресом, то первый замолкает
  * Если в течение 255 секунд не было опросов, то другой роутер начинает опрашивать
* Query-response interval - 10 секунд (ждем ответ)
* Timeout - 260 секунд (если не было активных ответов из группы, то вычеркиваем ее)
  * Если кто-то из группы уже сообщил роутеру, что multicast-трафик в эту сеть передавать нужно, то никто другой из сети не будет слать сообщение об этом.
    Дело в том, что хост роутеру шлет тоже multicast-сообщение (хотя на канально уровне это как broadcast), и все другие хосты его тоже слышат
* На хосте:
  * Отправка группового сообщения:
    * Ждем случайное количество времени от 0 до 10 секунд, слушая другие хосты
    * Если никто до нас не отправил, то отправляем сами
  * Предположим, что какое-то приложение только что стартовало в нашей сети, и оно еще не знает, согласился ли кто-то из сети на прием multicast-сообщений.
    Тогда оно само шлет сообщение об этом роутеру. Такое сообщение называется unsolicitated membership report
  * Хост так же может прислать всем роутерам (224.0.0.2) leave-сообщение

> [!NOTE]
> Если кто-то создаст новую группу, то как хосты о ней узнают?
>
> Ответ: никак. Это настраивается вручную, так как обычно мы знаем, от кого мы хотим получать трафик.

## Коммутаторы и snooping

* Поддердивается в IGMPv2, реже - в IGMPv3
* Если коммутатор достаточно умный, то он может подслушивать общение хостов и роутеров и использовать полученную инфу для более умной пересылки.
  * *Проблема*: У нас всегда отвечает о желании прослушивать multicast-трафик первый из группы. А как узнать, хотят ли остальные хочты все еще получать этот трафик?
  * Решение такой проблемы: коммутатор блокирует все IGMP-сообщения (кроме тех, что от роутера) и посывает роутеру одно в ответ
    (к примеру, первое, которое пришло самому коммутатору). Соответственно, другие хосты не слышат, что кто-то из группы уже ответил, и шлют на
    коммутатор тоже такие сообщения. Так коммутатор может понять, кто в локальной сети хочет получать multicast-трафик.
    * Но появляется новая проблема: Хосты думают, что либо они всегда первые посылают сообщение, либо что они вообще одни в группе в этой локальной сети

> [!NOTE]
> TCP не поддерживает multicast.

* Альтернатива snooping'у - протокол CGMP (Cisco Group Management Protocol)

> [!IMPORTANT]
> IGMP не достаточно для маршрутизации группового трафика. Он только для локального взаимодействия. Действительно, все ломается, если у нас в сети есть много локальных сетей, соединенных роутерами.
> Не понятно, как роутеры будут между собой определять, нужно им пересылать multicast-трафик, или нет. Но есть "костыльное" решение, применимое в некоторых ситуация -
> IGMP Proxy.

### IGMP Proxy

Мы можем (вручную) настроить роутеры, чтобы они не пересылали IGMP-сообшения по каким-то связям так, чтобы итоговый граф сети имел древовидную топологию. 
После этого можно настроить некоторые роутеры, чтобы они работали в режиме прокси, т.е. они будут посылать IGMP-опросы о членстве в группах вниз, от корня, 
но в сторону корня будут просто пересылать пришедший снизу трафик. Для понимания рассмотрим картинку:

![сети](https://github.com/AliakseiSuvorau/networks/assets/98915109/389a00e5-7613-43e4-b620-508dc18f29d5)

У такого решения существуют проблемы:
* Выделен корень. Только из него можем рассылать multicast-сообщения
* Ручная настройка
