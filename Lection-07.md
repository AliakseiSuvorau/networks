# Лекция 7

## Фрагментация
* Механизм разбиения кадров
* *Необходимость*: хотим посылать что-то большое, но сталкиваемся с ограничениями устройств сети
  
> [!NOTE]
> В IPv4 реализован алгоритм фрагментации. В IPv6 официально алгоритма фрагментации нет, но его можно сделать с помощью дополнительных опций.

* *Идентификатор* - значение, которое назначает отправитель пакета для определения корректной последовательности фрагментов при сборке дейтаграммы.
* Флаги:
  * 0-й: всегда равен нулю
  * 1-й: DF (Don't fragment) - возможность фрагментации (1 - нельзя фрагментировать)
  * 2-й: MF (More fragments) - указывает на то, что текущий фрагмент не последний (1) или что за ним больше не будет фрагментов (0).

* Смещение - позиция фрагмента в потоке данных в 8-байтных блоках.

> [!NOTE]
> Фрагменты идут с выравниванием по 8 байт.

> [!WARNING]
> Мы не используем нумерацию фрагментов, потому что дейтаграммы могут фрагментироваться несколько раз, и тогда непонятно, как их нумеровать.

> [!TIP]
> *Связь размера предыдущих кадров и смещения*
> 
> Пусть размер первого фрагмента - 1500. Тогда смещение второго фрагмента можно вычислить так: $\left\lceil\frac{1500-20}{8}\right\rceil=185$, где 20 - размер заголовка.

### Проблемы фрагментации

* Дополнительная нагрузка на сетевые устройства
* В случае фрагментации фрагменты ссобщения будут задержаны в сетевом стеке, пока сообщение не будет собрано полностью, и только потом сообщение будет отдано приложению для обработки
* Вспомним, что сообщения могут искажаться или вообще не доходить. Если мы потеряли один из фрагментов, то мы ждем некоторое время, по истечении которого, не дождавшись недостающего фрагмента,
  отбрасываем все пришедшие фрагменты.

> [!NOTE]
> В таком случае отправляется icmp-сообщение об ошибке.

> [!NOTE]
> Роутер не проверяет, все ли фрагменты ему пришли, а просто пересылает все, что ему пришло, дальше.

## Опциональные поля (легаси)

* Могут отсутствовать
* Их обработка должна быть реализована на всех хостах и шлюзах

> [!IMPORTANT]
> Современные устройства могут отбрасывать дейтаграммы с опциональными полями.

* Copy (1 бит)
  * 1 - опции копировать в заголовки всех фрагментов
  * 0 - оставить их только в первом

* Класс (2 бита)
  * 0 - управление (самый обычный режим работы)
  * 2 - отладка и измерение
  * 1 и 3 - зарезервированы

* Номер опции (5 бит)
* Длина опции (8 бит, может отсутствовать)
* Данные (переменной длины, кратны 8 битам, могут отсутствовать)

### Опции

* End of options (класс 0, номер 0, длина 1 октет)
  * Завершает перечень опций (если окончание не совпадает с концом заголовка)
* No options (класс 0, номер 1, длина 1 октет)
  * Может быть использована для выравнивания между опциями
* Loose Source Route (класс 0, номер 3, переменной длины)
  * При маршрутизации от источника (см. способы определения маршрута)

> [!NOTE]
> На Windows можно запустить команду `ping` с флагом `-r`. Она строит путь (в том числе и в обратную сторону) из узлов на пути пакета. Длина пути не превышает 9.

* Timestamp (класс 2, номер 4, переменной длины)
  * Время прохождения пакета через узел

> [!NOTE]
> На Windows можно запустить команду `ping` с флагом `-s`.

## Маршрутизация

### Задачи маршрутизации

* Поиск наилучшего пути доставки пакета
* Принцип получения маршрута
  * Статический
  * Динамический (хосты договариваются между собой)
* Способ определения маршрута
  * От источника (source-based) - источник говорит, как должен доставляться пакет
    * Жёсткая (strict)
    * Гибкая (loose) - пакет дойдет до куда-то, а там другие устройства решат, что с ним делать
  * По получателю (destination-based)

> [!NOTE]
> OSPF - протокол динамической маршрутизации. Нужен для того, чтобы маршрутизаторы могли узнавать новые маршруты в сети.

### Таблица маршрутизации

1. Сетевой адрес
2. Маска сети
3. Адрес шлюза - сосед, на которого спихнем пакет.

> [!NOTE]
> *Шлюз по умолчанию* - узел, на который пакет отправляется в том случае, если маршрут к сети назначения пакета неизвестен.
> Оно управляет пересылкой информации из одной сети в другую, что позволяет разделять потоки информации, идущие из одной сети в другую, и потоки, не выходящие за пределы одной сети.

4. Интерфейс (могут быть разные сетевые карты)
5. Метрика (выгоднее маршрут с меньшим значением метрики)

### Выбор адреса из таблицы маршрутизации

* Берем адрес, накладываем маску. Если поулченный адрес присутствует в таблице маршрутизации, то нашли, куда отправлять
* 0.0.0.0 - по умолчанию (при наложении маски не меняется, используется в последнюю очередь)
* 224.0.0.0 - multicast
* 255.255.255.255 - broadcast

### Алгоритм работы маршрутизатора

1. Проверяем, соответствует ли адрес назначения локальной сети. Если да, то посылаем через локальный интерфейс
2. Поиск записи в таблице маршрутизации. Накладываем максимальную маску и проверяем соответствия

> [!TIP]
> Пусть в таблице маршрутизации имеем такие строки:
> | Адрес      | Маска         |
> |------------|---------------|
> | 10.0.0.0   | 255.0.0.0     |
> | 10.16.0.0  | 255.255.0.0   |
> | 10.16.29.0 | 255.255.255.0 |
>
> Хотим послать на адрес 10.16.27.19. Алгоритм перебора масок будет работаь так: сначала проверим 10.16.27.19. Его не будет.
> Наложим маску 255.255.255.0 и проверим 10.16.27.0. Его нет. Наложим маску 255.255.0.0 и проверим 10.16.0.0. Он есть, на него и посылаем.
>
> Маски выбираем из тех, что есть в таблице.

3. Если  адрес не найден и  есть маршрут по умолчанию, то используем его
4. Если нет маршрута по умолчанию, то посылаем icmp-сообщение об отсутствии маршрута (Destination host unreachable).

> [!NOTE]
> Роутер, в отличие от коммутатора, может отправлять пакеты на тот же интерфейс, с которого его получил.

> [!TIP]
> Рассмотрим пример статического заполнения таблицы маршрутизации. Пусть наша сеть имеет вид:
> ![network-scheme](https://github.com/AliakseiSuvorau/networks/assets/98915109/22c812db-60bd-4ef3-af3d-63119178c4f3)
>
> Легенда:
> * A, B, C, D, E, F, G - локальные сети
> * R1, R2, R3, R4, R5 - маршрутизаторы
> * Цифры рядом с маршрутизаторами - номера интерфейсов
>
> В качестве метрики будем использовать количество роутеров на пути.
> 
> Таблица маршрутизации для R4:
> | Метка | LAN | Отправляем с | Отправляем на | Метрика |
> |----|---|------|------|---|
> | 🟢 | A | R1.2 | R4.1 | 2 |
> | 🟡 | A | R2.2 | R4.2 | 3 |
> | 🔴 | A | R5.1 | R4.2 | 4 |
> | 🟢 | B | R1.2 | R4.1 | 2 |
> | 🟢 | B | R2.2 | R4.2 | 2 |
> | 🟢 | D | R2.2 | R4.2 | 2 |
> | 🟡 | D | R1.2 | R4.1 | 3 |
> | 🟢 | E | R2.2 | R4.2 | 3 |
> | 🟡 | E | R1.2 | R4.1 | 3 |
> | 🟢 | G | R5.1 | R4.2 | 2 |
> | 🟡 | G | R1.2 | R4.1 | 3 |
>
> Здесь 🟢 обозначает нормальный маршрут, 🟡 - сомнительный, но который тоже имеет место быть, а 🔴 - извращенский (здесь мы отправляем пакет обратно а ту же сеть, из которой его получили).
> Далее буду показывать только кратчайшие маршруты.
>
> Таблица маршрутизации для R1:
> | LAN | Отправляем с | Отправляем на | Метрика |
> |---|------|------|---|
> | D | R2.1 | R1.3 | 2 |
> | E | R2.1 | R1.3 | 3 |
> | F | R2.1 | R1.3 | 2 |
> | F | R4.1 | R1.2 | 2 |
> | G | R2.1 | R1.3 | 3 |
> | G | R4.1 | R1.2 | 3 |
>
> Таблица маршрутизации для R2:
> | LAN | Отправляем с | Отправляем на | Метрика |
> |---|------|------|---|
> | A | R1.3 | R2.1 | 2 |
> | E | R3.1 | R2.3 | 2 |
> | C | R1.3 | R2.1 | 2 |
> | C | R4.2 | R2.2 | 2 |
> | G | R5.1 | R2.2 | 2 |
>
> Таблица маршрутизации для R3:
> | LAN | Отправляем с | Отправляем на | Метрика |
> |---|------|------|---|
> | A | R2.3 | R3.1 | 3 |
> | B | R2.3 | R3.1 | 2 |
> | C | R2.3 | R3.1 | 3 |
> | F | R2.3 | R3.1 | 2 |
> | G | R2.3 | R3.1 | 3 |
>
> Таблица маршрутизации для R5:
> | LAN | Отправляем с | Отправляем на | Метрика |
> |---|------|------|---|
> | A | R2.2 | R5.1 | 3 |
> | A | R4.2 | R5.1 | 3 |
> | B | R2.2 | R5.1 | 2 |
> | C | R4.2 | R5.1 | 2 |
> | D | R2.2 | R5.1 | 2 |
> | E | R2.2 | R5.1 | 3 |
