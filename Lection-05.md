# Лекция 5

## Содержание

* [Дополнительные сервисы канального уровня](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-05.md#дополнительные-сервисы-канального-уровня)
* [STP](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-05.md#stp-spanning-tree-protocol)

## Дополнительные сервисы канального уровня

### Агрегированные каналы

* Идея: хотим объединить несколько физических каналов между устройствами в один логический

> [!NOTE]
> Просто подключить соседние устройства несколькими каналами связи не получится. Предположим, что какое-то устройство захотело отправить broadcast-сообщение.
> Тогда, дойдя до соседнего устройства, это сообщение пойдет по всем дублирующим каналом обратно, и т.д. Такая ситуация называется широковещательный шторм.

* Подходы:
  * Статический - говорим, какие физические каналы всегда будут ассоциироваться с один логическим
  * Динамический - коммутаторы сами договариваются посредством специального протокола LACP

> [!NOTE]
> За агрегацию каналов отвечает Link aggregation sublayer, расположенный между MAC и LLC (см. [Лекцию 3](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-03.md#ethernet))

* Балансировка пакетов
  * На уровне кадров
    * Первый кадр в первый канал, второй - во второй, и т.д.
    * Плюс:
      * Близкое к равномерному распределение кадров между каналами
    * Минус:
      * Протоколы более высоких уровней могут быть чувствительны к порядку кадров, а в такгой конфигурации разные кадры в зависимости от свойств канала и размера кадра могут приходить не по порядку

  * На уровне mac-адресов
    * Определяем, на какой адрес идут сообщения, или с какого адреса идут сообщения, или какие пары адресов общаются межуд собой

> [!NOTE]
> Могут быть использованы адреса с более высокого уровня для добавления гибкости, но это потребует более умных коммутаторов

* Алгоритмы баланрировки
  * Вычисление номера канала как функции от адреса абонента
  * В тупую: циклический буфер

> [!IMPORTANT]
> Балансировка по отправителю и получателю работает независимо. Это позполяет избежать ситуации, когда в коммутатор приходит информация по большому
> количеству мелких каналов от большого количества устройств, а передать всю эту информацию надо одному устройству, сидящему на широком канале. В таком случае балансировку надо делать по отправителю.


> [!IMPORTANT]
> Нужно получать ip-адрес в случае, когда к коммутатору подключен роутер, так как тогда вся информация будет приходит с одного только mac-адреса роутера.


> [!IMPORTANT]
> Динамическая агрегация каналов работает только между соседними устройствами. Статическая агрегация может быть сделана не только между соседними, хотя такое крайне не желательно.

* В итоге получаем
  * Увеличение скорости передачи кадров
  * Высокую надежность логических каналов

## STP (Spanning tree protocol)

* Используется для обеспечения отсутствия петель коммутации
* Построение:
  * В каждом узле храним приоритет. При равенстве приоритетов узлов будем использовать mac-адрес
  * Выбираем корень
  * От корня строим пути с минимальными стоимостями
  * Разрываем все соединения, не входящие в остов

> [!NOTE]
> Стоимость зависит от пропускной способности канала.


> [!NOTE]
> Для разных VLAN'ов стоит использовать разные остовные деревья (см. MSTP).

* Выбор корня
  * Добавляется новое состояние порта: Listening
  * В начальный момент все коммутаторы - корни
  * Они начинают рассылать соседям BPDU-пакеты со своим ID
  * Если у соседа ID меньше, то считаем корнем соседа
  * Через несколько итераций все будут знать, кто корень

> [!NOTE]
> Тайминги выбираются в зависимости от диаметра сети.


> [!NOTE]
> Агрегированный канал участвует в построении остовного дерева как единая сущность.

### RSTP

* Быстрый STP
* Решаем проблему задержки за счет того, что выкидываем лишнее состояние порта
* Появляются краевые порты, т.е. порты, за которыми гарантированно нет петель коммутации

> [!NOTE]
> Если из краевого порта пришел BPDU, то этот порт больше не считаем краевым
