# Доп. лекция

## SCTP (Stream Control Transmission Protocol)

* Базовый стандарт - RFC 2960
* Улучшение TCP
* Что есть?
  * Как в TCP:
    *  Надежность
    *  Борьба с перегрузками
    *  Установление соединения
  * Новое:
    * 4-way handshake (для борьбы с SYN flood атаками)
    * Сохранение границ сообщений
    * Multistreaming (в рамках одной ассоциации можем построить несколько соединений)
    * Multihoming (вместо одногоip-адреса на эндпоинт имеем набор ip-адресов)

> [!NOTE]
> *Проблема*: NAT'ы скорее всего не будут поддерживать.

### 4-way handshake

* *Проблема 3-way handshake*: при получении SYN-пакета сервер выделяет ресурсы для установки TCP-соединения. Но они могут в какой-то момент закончиться.

#### Установление соединения:

1) Клиент посылает серверу INIT-пакет.
2) Сервер посылает клиенту INIT-ACK, но ресурсы еще не выделяет.
3) Клиент посылает серверу COOKIE-ECHO.
4) Сервер получает от клиента COOKIE-ECHO, посылает в ответ COOKIE-ACK и выделяет ресурсы на соединение.
5) После этого клиент начинает слать данные.

### Границы сообщений

* Если сообщение больше - то бьем на чанки и отмечаем начало и конец сообщения
* *Чанк* в SCTP:
  * 8 бит - тип
    * DATA - для посылки данных
    * INIT, INIT-ACK - для открытия соединения
    * SHUTDOWN, SHUTDOWN-ACK - для разрыва соединения
    * SACK - селективные подтверждения
    * HEARTBEAT, HEARTBEAT-ACK - для механизма keep-alive
  * 8 бит - флаги (UBE)
  * 16 бит - длина
  * Данные

#### DATA Chank

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/ede07998-526f-4690-b44d-2fcaa1dc0320)

* Передаем чанки под общим хедером
* Если не можем перелать - фрагментируем
* **Фрагментация**:
  * Флаги:
    * B (Beginning) - выставлен в 1 у первого фрагмента
    * E (Ending) - выставлен в 1 у последнего фрагмента
  * SID - одинаковый в пределах одного потока
  * TSN - увеличивается для каждого следующего фрагмента
  * SSN - увеличивается для каждого следующего сообщения, но одинаковый для всех фрагментов одного сообщения

### Multistreaming

* *Пример*: телефония. Потеряли один пакет. Но обрабатываем много телефонных разговоров одновременно. Нельзя ждать этот один потерянный пакет, не передавая остальные дальше
* *Проблема*: Первый и третий пакеты доставлены, а второй - нет. В TCP мы не пошлемтретия пакет приложению, пока не получим второй. Но нам может быть не важно, чтобы пакеты приходили по порядку
* *Решение*: много потоков. Если в каком-то потоке потеряется пакет, то от этого будет страдать только этот поток

### Multihoming

* Пусть у хостов A и B есть по 2 сетевых интерфейса. Тогда имеем 4 возможных соединения: {(A1, B1), (A1, B2), (A2, B1), (A2, B2)}.
* *Проблема*: приходится самим на уровне хостов понимать, что надо сделать 4 соединения и как между ними балансировать нагрузку
* *Решение*: создаем ассоциацию между хостами, в рамках которой будут наши соединения. Выберем первичный канал, по которому и будем передавать информацию. Если первичный канал упадет - то выберем один из оставшихся.
  **Но**: в базовой версии SCTP нетвозможности посылать данные параллельно через несколько каналов
