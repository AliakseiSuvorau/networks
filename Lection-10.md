# Лекция 10

## TCP (Transmission Control Protocol)

### Общая информация

* Основной стандарт: RFC 793
* Работает поверх ip

### Задачи и характеристики TCP

* Протокол с установлением соединения
  * Обмен начальными параметрами, которые определяют режим функционирования соединения
  * Также есть алгоритм нормального завершения соединения
* Двунаправленная передача данных в рамках соединения
  * Передача в одну сторону независимо от передачи в другую сторону
* Множество соединений
  * Соединения определяется парой id абонентов
* Надежная передача данных
  * Либо передадим сообщение, либо поймем, что он оне дошло
  * Получаем отклик о том, что сообщение получило, или по истечении таймаута происходит перепосылка

> [!NOTE]
> В UDP icmp-сообщение может быть заблокировано и может не дойти.

* Подтверждение получения данных
* Управление средуой передачи данных
  * Смотрим на возможности сети и не передаем много
* С потоковой передачей данных
* Передаем произаольные данные
  * Не имеющие определенной структуры данные
  * Может быть такое, что TCP сожмет несколько отдельных сообщений в одно, или одно большое сообщение разделит на части вне зависимости от того, где эти все сообщения изначально начинались и кончались

**Сегменты** - единицы передаваемых через TCP данных.

### Формат заголовка

| Размер в битах | Название поля | Информация |
|-|-|-|
| 16 | src port | |
| 16 | dst port | |
| 32 | Sequence Number | Как смещение в ip, но это номер бита в рамках потока передачи данных |
| 32 | Acknowledgment Number | Номер последовательности, ожидаемый отправителем в следующий раз. Относится в параллельному потоку "в другую сторону". Рассматривается только если выставлен флаг ACK |
| 4 | Data Offset | Из-за опций заголовок имеет переменную длину. Сдвиг считается от начала заголовка в 4-октетных блоках |
| 6 | | Зарезервированы. Иногда здесь указываются дополнительные флаги |
| 6 | Флаги | |
| 16 | Окно | Размер принимающего буфера |
| 16 | Checksum | |
| 16 | Urgent pointer | Указывает сдвиг в данных до "важных данных", которые стоит обработать раньше остальных. Рассматривается только елси выставлен флаг URG. Легаси |
| 24 | Опции | |
| 8 | Отступ | |
| | Данные | |

> [!NOTE]
> Пусть у нас будет такой порядок доставки сегментов:
> | 1 | 2 | | 4 | 5 |
> |-|-|-|-|-|
> 
> То есть 3 сегмент не получен. Тогда в Acknowledgement number будет стоять номер бита, с которого начинается третий сегмент.

> [!NOTE]
> В случае, если не получин какой-то сегмент, то придется пересылать заново все сегменты.

> [!NOTE]
> Если при указании смещения возникает переполнение, то берем по модулю.

> [!NOTE]
> Окно вмещает не больше чем $2^{16}$ битов, что мало. Поэтому появляется опция с масштабом окна.

### Флаги
Идут в таком порядке:
* URG
  * Лучше не пользоваться, т.к. промежуточные устройства могут убирать этот флаг
  * Указывает, что в Urgent pointer находится значение
* ACK
  * Указывает, что в Acknowledgment Number находится значение
* PSH
  * Изначально: в сообщении находятся важные данные, которые нельзя задерживать
  * Сейчас: в момент передачи этих данных в буфере отправителя было пусто

Флаги, связанные с установкой и разрывом соединения:
* RST
  * Отказ от соединения
  * Соединение не может быть установлено
  * Обрываем соединение
* SYN
  * Для установки соединения
* FIN
  * Указывает, что больше нет данных и можем вежливо закрывать соединение
  * После этого мы не можем слать ничего кроме подтверждений о получении сообщений
  * А наш партнер может слать что угодно

### Опции

* масштаб окна
* согласование размера сегмента (MSS)
* ...

### Установление соединения (3-Way Handshake)

1) Изначально есть 2 устройства. Первое (активное) начинает установку соединения, отправляя второму (пассивному) пакет `SYN`.
   После этого первое устройство переходит в состояние `SYN-SENT`. В `SYN`-пакете есть поле `SEQ`, которое изначально содержит случайное число,
   генерируемое активным устройством.
2) Пассивное устройство посылает в ответ пакет `SYN+ACK` и переходит в состояние `SYN-RCVD`. Пакет `SYN+ACK` содержит поле `ACK`, значение которого -
   увеличенное на 1 значение поля `SEQ` из полученного пакета `SYN`. Также пассивное устройство генерирует случайное число и помещает
   его в поле `SEQ` пакета `SYN+ACK`.
3) Активное устройство должно подтвердить установление соединения, отправив в ответ на пакет `SYN+ACK` пакет `ACK`. В нем есть поле `SEQ`,
   содержащее значение, равное значению поля `ACK` из пакета `SYN+ACK`, а также поле `ACK`, содержащее значение на один больше, чем значение
   поля `SEQ` из пакет `SYN+ACK`. После посылки этого сообщения активное устройство переходит в состояние `ESTABLISHED`.
4) При получении пакета `ACK` пассивное устройство тоже переходит в состояние `ESTABLISHED`.
5) Далее устройства обмениваются пакетами, каждый раз увеличивая поля `SEQ` и `ACK` на размер передаваемых данных, меняя их местами.

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/f07b1462-5827-4a98-aff3-4deae08c605b)

### (Вежливое) завершение соединения

1) Изначально оба устройтсва находятся в состоянии `ESTABLISHED`. Первое из них (которое хочет завершить соединение) посылает второму пакет `FIN`
   и переходит в состояние `FIN-WAIT-1`. В пакете присутствуют поля `SEQ` и `ACK`.
2) Второе устройство получает пакет `FIN` и посылает пакет-подтверждение `ACK`, содержащий поле `SEQ` со значением, равным значению поля `ACK`
   из полученного пакета `FIN`, и поле `ACK` со значением из поля `SEQ` пакета `FIN`, величинным на единицу. После этого второе устройство переходит в
   состояние `CLOSE-WAIT`.
3) Получив пакет `ACK` от второго устройства, первое устройство переходит в состояние `FIN_WAIT_2`.
4) Далее второе устройство может продолжать слать первому данные, увеличивая `SEQ` и `ACK`.
5) Когда второе устройство решает закрыть соединение, оно шлет первому пакет `FIN`. содержащее поля `SEQ` и `ACK`, и переходит в состояние `LAST_ACK`.
6) Первое устройство после получения пакета `FIN` шлет в ответ пакет `ACK`. В нем содержется поле `SEQ`, равное значению поля `ACK` из полученного пакета `FIN`,
   и поле `ACK`, значение которого равно значению поля `SEQ` из пакета `FIN`, увеличенному на один. После этого первое устройство переходит в состояние
   `TIME_WAIT` (оно нужно для того, чтобы перепослать пакет `ACK`, если он не дошел)
7) После этого оба устройства переходят в состояние `CLOSED`.

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/c6f813b9-194f-4f0e-90cc-e74f093d3c9b)

### Состояния

Взглянем еще раз на граф состояний TCP:

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/57765caa-19c9-4e24-823d-169ddc071c74)

#### Установка соединения

* `LISTEN` - состояние ожидания запроса на соединение от удаленного абонента
* `SYN-SENT` - состояние ожидания совпадающего запроса на соединение, после посылки запроса на соединение
* `SYN-RCVD` - состояние ожидания подтверждения на запрос соединения, после посылки и получения запроса на соединение
* `ESTABLISHED` - состояние представляющее открытое соединение (нормальное состояние передачи данных)

#### Разрыв соединения

* `FIN-WAIT-1` - состояние ожидания запроса на завершение соединения от удаленного партнера
* `FIN-WAIT-2` - состояние ожидания запроса о завершении соединения от удаленного партнера
* `CLOSE-WAIT` - состояние ожидания запроса о завершении соединения от локального пользователя
* `CLOSING` - состояние ожидания подтверждения запроса о завершении соединения от удаленного партнера
* `LAST-ACK` - состояние ожидания подтверждения запроса завершения соединения ранее посланного удаленному партнеру
* `TIME-WAIT` - состояние ожидания на время достаточное для получения удаленным партнером подтверждения на его запрос о завершении соединения
* `CLOSED` - состояние отсутствия соединения

### Скользящее окно

* Пошли пакет и подожди подтверждения
* Минус:
  * Медленно - в каждый момент передается только один сегмент => низкая скорость передачи

> [!NOTE]
> Повторное (даже дублированное) сообщение надо тоже подтвердить.

* Позволим передавать несколько неподтвержденных сообщений одновременно
* **Окно** - количество пакетов, которое можно передать без подтверждения
* Сообщения нумеруем по модулю (чтобы не было переполнения)
* Окно скользит по данным в зависимости от смещения подтвержденных данных

#### Отправитель

* 3 переменных:
  * размер окна отправителя (SWS)
  * № последнего полученного подтверждения (LAR)
  * № последнего отправленного сегмента (LSS)

* Отправитель обязан:
  * обеспечить LSS - LAR $\leq$ SWS
  * буферизация последних SWS запросов (т.к. если не получим подтверждения, то придется их перепослать)
  * увеличить LAR при получении подтверждения

#### Категории данных отправителя

#### Получатель

* 3 переменных:
  * размер окна получателя (RWS)
  * № последнего допустимого сегмента (LAS)
  * № последнего полученного сегмента (LSR)

* Получатель обязан:
  * обеспечить LAS - LSR $\leq$ RWS
  * подтверждать сегменты с номерами меньше LAS
    * куммулятивные подтверждения

#### Категории данных получателя

### Selective Acknowledgment

* *Проблема*: из пакетов 1 - 20 не получаем второй => придется перепослать все
* *Решение*: указываем, что после второго получили (в опциях)

### Фрагментация в TCP

* *Проблема*: не любим фрагментирование в ip
* *Решение*:
  * Максимально допустимый (по стандарту) размер сегмента, при котором гарантированно не произойдет фрагментации - 576 октет
  * В опциях есть поле MSS, в котором отправитель и получатель могут договориться о размере сегмента при установлении соединения.
    Это поле могут менять умные промежуточные устройства
  * Если видим, что большие сообщения не доходят (нет подтверждений), то уменьшаем размер до стандартного
