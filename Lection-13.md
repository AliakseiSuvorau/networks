# Доп. лекция

## DNS

* Сопоставление символьных имен сетевым адресам
* Построение иерархического адресного пространства
* Создание распределенной инфраструктуры для разрешения символьных имен в сетевые адреса
* Базовые стандарты: RFC 1034 и RFC 1035 (1987 г.)
* Раньше: hosts.txt - маппинг храним в файле (сейчас тоже можно встретить)

### Задачи

* Масштабируемость
  * Поддержка огромного количества имен, в том числе генерируемых автоматически в реальном времени
* Распределенное управление
  * Владельцы имен сами отвечают за их поддержание и модификацию
* Устойчивость к ошибкам
  * Резервирование
  * Кэширование (локальное и на сервере)
  * Обработка ошибок

* В итоге имеем:
  * Load-mostly DB
  * Loose consistency (нам не критично мгновенно обновляться, чтобы иметь актуальные данные)

### Компоненты инфраструктуры

* Пространство доменных имен и ресурсные записи
* Сервера имен
* "Разрешатели" имен (Resolvers)

#### Пространство имен

* Ограничения
  * Стандартные:
    * Использования латинских символов
    * 63 октета на максимальный размер метки
    * 255 октетов на максимальный размер адреса
    * *Пример*: `mipt.ru` - адрес, а `mipt` и `ru` - метки
  * Расширенные:
    * Можно использовать unicode и emoji

* Домены состоят из набора зон
  * Каждый домен делегирует управление следующим поддоменам
  * Каждая зона имеет реплику для надежности
#### Ресурсные записи

Представляют собой информацию, хранящуюся в базе данных DNS и связанную с определенными доменными именами.

#### Сервера имен

Когда хост делает запрос к доменному серверу, то он одидает получить ответ, а не перенаправление на другой сервер. Но сервера между собой могут общаться такими пересылками.

Идем с хоста в локальный DNS-сервер. Он стучится в корневой DNS-сервер, и оттуда начинаем раскручивать метки, пок ане дойдем до нужного адреса или не поймем, что его нет.

#### Разрешатель

* Находится на хосте
* Клиент: либо смотрит кэш, либо делает запрос к внешним серверам
* Сервер: имеет те же компоненты, что и клиент, но resolver ходит не в кэш, а в БД. Таже может обращаться к другим серверам

### Типы взаимодействия клиент-сервер

* Рекурсивыне запросы
  * сервер берет на себя роль resolver'а
  * можно настроить сервер так, чтобы он не обслуживал внешних клиентов
* Итерационные запросы
  * сервер не делает рекурсивный обход, а возвращает ссылку на товарища, который обладает более подробной информацией

### Транспорт для DNS

* адресное общение (unicast)
* дейтаграммный (UDP) и потоковый (TCP) режимы передачи
  * UDP: порт сервера - 53, ограничения: в IPv4 - 512 байт, в IPv6 - 1240 байт. Это стандартный режим работы
  * TCP: границы сообщения - 64К

### Формат ресурсной записи (RR)

1) NAME - домен владельца RR
2) Type
3) Class - семейство протоколов (почти всегда - ip)
4) TTL - время жизни RR в кэше клиента
5) RDLENGTH - размер поля данных RR
6) RDATA - само поле с данными

### Типы RR

* А - адрес хоста (в данных - ip-адрес)
* NS - авторитетный Name Server (в данных - имя хоста (не адрес!))
* CNAME - псевдоним (в данных - доменное имя)
* SOA - метка начала зоны ответственности. Поля:
  * MNAME - имя основного сервера
  * RNAME - адрес почтового ящика человека, ответственного за зону
  * SERIAL - число, определяющее номер копии зоны. Можем понять, были ли какие-то изменения в зоне и надо ли их запрашивать. При изменении зоны инкрементируется
  * REFRESH - время, через которое надо обновить зону
  * RETRY - минимальное время перед повторной попыткой обновить информацию о зоне после неудачной попытки
  * EXPIRE - верхняя граница времени, после которого считаем информацию недействительной
  * MINIMUM - минимальный TTL, который экспортируется с RR из данной зоны
* PTR - указатель на доменное имя, а-ля обратное преобразование (в данных - доменное имя)
* MX - точка обмена электронными сообщениями
* TXT - текстовая строка
* SRV - поиск сервиса в сети

### Формат сообщения DNS-протокола

* Header
* Question - запрос к главному серверу
* Answer - RR с ответом
* Authrity - RR, указывающая на авторитетный сервер, отвечаем за зону
* Additional - доп. информация от сервера

### Формат заголовка

![image](https://github.com/AliakseiSuvorau/networks/assets/98915109/46aec235-3590-4cee-8039-fe42229d3c82)

* ID – идентификатор запроса, выбирается клиентом, должен совпадать во всех ответах на данный запрос
* QR – признак запроса / ответа
* Opcode – код операции
  * 0 - a standard query (QUERY)
  * 1 - an inverse query (IQUERY)
  * 2 - a server status request (STATUS)
  * 3-15 - reserved for future use
* Флаги:
  * AA – ответ от ответственного за домен сервера имен
  * TC – сообщение было обрезано из-за ограничений на размер пакета
  * RD – клиент желает выполнить рекурсивный запрос, а не итерационный
  * RA – сервер способен выполнять рекурсивные запросы
  * Z – зарезервированно
* Коды ответа:
  * RCODE – содержит признак успешности выполнения запроса
    * 0 – нет ошибок
    * 1 – ошибка формата запроса
    * 2 – сбой на сервере
    * 3 – ошибка имени в запросе (имени нет в данном домене); приходит только от ответственных за домен серверов
    * 4 – сервер не реализует данный тип запросов
    * 5 – сервер отказал в обслуживание из-за административных ограничений

### Алгоритм работы разрешателя

1) Поиск ответа в локальной базе, если найден - вернуть ответ клиенту
2) Найти сервера, наиболее подходящие для получения ответа на запрос пользователя
3) Посылать запросы данным серверам, пока они не вернут ответ
4) Проанализировать ответы:
  * Если в ответе содержится информация о запрошенной записи или ошибке в имени, то поместить данную информацию в кэш и вернуть ее клиенту
  * Если ответ содержит информацию о переадресации на другой сервер, поместить информацию о данном сервере в кэш и вернуться к пункту 2
  * Если в ответе содержится запись типа CNAME (CNAME - псевдоним, указывающий на другое доменное имя), которая не является ответом на запрос, поместить данную запись в
    кэш, изменить поле SNAME в запросе на каноническое имя, которое получено на данном этапе, и перейти к пункту 1
  * Если ответ содержит код ошибки сервера или ответ является «странным», то удалить данный сервер из списка серверов и перейти к пункту 3

### Алгоритм работы сервера

1) Установить или сбросить флаг рекурсивного запроса
  * Если рекурсивное выполнение возможно и запрошено клиентом, то переходим к шагу 5
  * Иначе - переходим к шагу 2
2) Делаем поиск зоны, которая является наиболее близким предком к запрашиваему имени QNAME (QNAME - это часть DNS-запроса, которая содержит имя домена, для которого
  запрашивается ip-адрес)
  * Если зона найдена, то переходим к шагу 3
  * Иначе - переходим к шагу 4
3) Процесс сравнения, от метки к метке в зоне. Останавливаемся, если:
  * Пусть нашли полное имя запроса, тогда:
    * Если данные об узле являются CNAME, но тип запроса QTYPE (QTYPE = тип RR) не является CNAME (т.е. мы нашли, что данное доменное имя - псевдоним для нашего адреса,
      но искали-то мы не псевдоним, а изначальный адрес), то копируем RR с CNAME в секцию ответов, изменим имя в запросе (QNAME) на то, куда указывает CNAME, и возвращаемся
      к шагу 1 (т.е. раскручиваем цепочку псевдонимов)
    * Иначе - если мы нашли не псевдоним, а изначальный адрес - то копируем в секцию ответов все RR с совпадающим QTYPE и переходим к шагу 6
  * Пусть при поиске вышли за пределы зоны ответственности (т.е. встретил NS-запись, перенаправляющую нас на другой сервер имен), тогда:
    * Формируем ссылку на дочерний домен, в зоне ответственности которого находися искомое имя (копируем NS-запись в секцию "авторитетные сервера" в ответе и добавим в
      дополнительную секцию информацию о данном сервере) и переходим к шагу 4
  * Пусть для метки не найдено совпадение. Тогда можем попробовать отправить ответ "по умолчанию". Ищем, есть ли "*":
    * Если такой метки нет:
      * Если текущий сервер - основной для зоны, то ответственно заявляем, что запрашиваемого ресурса нет и выставляем код ошибки (ошибка имени), после чего завершаем
        процесс
      * Если же сервер не является основным для зоны - то просто завершаем процесс
    * Если метка "*" найдена, то сравниваем тип RR (Type) и QTYPE:
      * Если совпадает - копируем содержимое RR в секцию ответов, но владельцем записи вместо "*" ставим имя из запроса (QNAME). После этого переходим к шагу 6
      * Если не совпадает - завершаемся без ошибок
4) Смотрим в кэш:
  * Если QNAME в кэше есть, то копируем все RR, совпадающие по типу (Type и QTYPE) в секцию ответов. Если для текущего сервера нет делегирования - то заполняем секцию "авторитетные сервера".
    Далее переходим к шагу 6
  * Иначе - завершаемся без ошибок
5) Действуем как клиент, используя локальный разрешатель. После чего переходим к шагу 6
6) Используя только локальные данные, попытаемся добавить дополнительную информацию (дополнительные RR, которые могут быть полезны). После чего завершаем процесс

### Безопасность DNS

Проблема: много уязвимостей, можно все подделать

* Для аутентификации:
  * DNSSEC
* Для конфиденциальности (используем криптографическое хеширование)
  * DNS поверх HTTPS
  * DNS поверх TLS

#### DNSSEC

  * Новые RR для аутентификации:
    * RRSIG - содержит криптографические подписи
    * DNSKEY - содержит публичные ключи
    * DS - содержит хеш от записей вида DNSKEY
    * NSEC и NSEC3 - для явного отрицания существования DNS-записи (записи, связанные с тем, что мы должны как-то ответить, если в нашей базе нет соответствующей RR)
* Подписываем сразу набор RR (т.к. подписывать каждую отдельно накладно)
* Имеем 2 вида ключей:
  * Для подписывания авторизованной информации
  * Для подписывания ключей (ключ, соответствующий некоторому серверу, менять проблематично, а ключи для подписи зонной информации менять легче)

**Как работает?**

Имеем публичный ключ для подписывания зонной информации. Подписываем на приватном ключе наборы RR. После этого разрешатель, получив публичный ключ и набор RR, может проверить подпись 
(с помощью записей вида DNSKEY). Возникает следующая пролема: все это хранится на одном сервере, а кто нам мешает подделать сервер целиком? Но у нас есть иерархия DNS-сервером, и информация
о ключах должна храниться на родительских серверах (записи вида DS). Таким образом, обратившись к родительскому серверу можно провалидировать, что дочерний сервер не является обманкой.
Так мы можем пройти вплоть до корневых серверов. Им мы должны верить.
