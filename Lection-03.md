# Лекция 3

## Содержание

* [Кодирование](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-03.md#кодирование)
* [Ethernet](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-03.md#ethernet)
* [Jumbo frames](https://github.com/AliakseiSuvorau/networks/blob/master/Lection-03.md#jumbo-frames-гигантские-кадры)

### Передача данных (физический уровень)

* Передача последовательности бит
* Характеристики модели:
  * Пропускная способность (бит в секунду)
  * Задержка (latency)
    * На передачу (зависит от длины сообщения)
    * На распространение
  * Другие:
    * Частота возникновения ошибок
    * Затухание сигнала

## Кодирование

  * 0 - слабый сигнал, 1 - сильный
    * Проблема потери синхронизации: сложно отличить 100 нулей от 101 нуля
    * Решение: блочные коды

  * Блочное кодирование
    * Один бит кодируется несколькими

### Помехозащищенное кодирование

  * Отправитель:
    * Исходные данные D
    * Проверочные коды R = F(D)

  * Ненадежный канал:
    * Channel: (D, R) -> (D', R')

  * Получатель:
    * Возможно искаженные данные D'
    * Возможно искаженные коды R'
    * Вычисляется проверочный код: R''=F(D')
    * Считаем, что все нормально, если R' = R''
    
### Расстояние Хемминга

  * Если расстояние Хемминга Н, то всегда можно обнаружить Н-1 ошибку
  * Для кода с расстоянием Хемминга Н всегда можно исправить $\left[\frac{H-1}{2}\right]$ ошибок

### Методы обнаружения ошибок (EDC)

* Бит четности: складываем по модулю 2 все биты)
* Контрольная сумма: суммирование частей пакета по 16 битов с переполнением (ее нет в IPv6)
* Циклический избыточный код: A - множество исходных сообщений, B - генератор (проверочного кода). В итоге делим A на B с остатком и получим проверочный код

> [!Note]
> Циклический избыточный код используется в Ethrnet.

## Ethernet

* Канальный уровень делится на 2 подуровня:
  * LLC - Logical link control
    * Управление логическими каналами
    * Определяется 3 типа функционирования коммуникационной инфраструктуры:
      * Без устрановки соединения и подтверждения (**используется в Ethrnet**)
      * С установкой соединения
      * С подтверждением, но без установки соединения
    * Предоставляются сервисы для протоколов верхнего уровня

  * MAC - Media access control
    * Управление доступом к среде
    * Функционал для обмена пакетами без установки соединения
    * Управление потоком данных между устройствами

* Стандарт IEEE 802
  * SAP - точка доступа к сервису, интерфейс
    * LSAP - интерфейс для вышележащих протоколов
    * MSAP - интерфейс для LLC для доступа к сервисам MAC-уровня

> [!IMPORTANT]
> В стандарте закреплены следующие положения:
> 1. Один mac-адрес для получения и передачи данных
> 2. Один широковещательный адрес для **получения** данных
> 3. Один или несколько multicast-адресов для **получения** данных


> [!NOTE]
> mac-адрес состоит из 48 битов. Первые 24 бита редставляют собой organization unique identifier.
> 7 бит определяет, универсальный(0) или локальный(1) адрес. 8 бит определяет, индивидуальный(0) или групповой(1) адрес.

### Поля пакета Ethrnet

 * 7 октетов вида `10101010` для стабилизации
 * 1 октет (маркерный кадр) вида `10101011`
 * 6 октетов - mac-адрес получателя
 * 6 октетов - mac-адрес отправителя
 * Длина (если $\leq1500$) или тип протокола (иначе)
 * Полезная информация:
   * MAC Client Data
   * Padding
  * Frame check sequence
  * ...

> [!NOTE]
> Максимальный размер для пользовательских данных - 1500 октет. Если надо передать больше - то разбиваем на несколько пакетов

### Режим работы устройств: прозрачный мост

* Состояния порта:
  * Discarding - все отбрасывает
  * Learning - добавление/удаление адресов в таблицу коммутации
  * Forwarding - работает штатно

### Active topology enforcement

* Часть алгоритма продвижения данных
* Порт, на котором получен кадр - в состоянии продвижения, порт-получатель - тоже
* Порт-получатель не является портом-отправителем (т.е. пакет не пойдет обратно)
* Проверяется размер кадра (если кадр слишком большой, то отбрасываем его)

### Обучение коммутатора

* Порт, получивший пакет - в состоянии forwarding/learning
* Адрес источника - не групповой
* Нет статических записей в таблице фильтрации (*Таблица фильтрации* содержит mac-адреса. Пакеты, идущие на них, будут отбрасываться)
* Табоица фильтрации имеет конечный размер. Если она переполнена, то кадры больше не рассылаются

> [!NOTE]
> Если не знаем, куда отправлять кадр, то шлем всем (с учетом вышеперечисленных условий)

### Jumbo frames (гигантские кадры)

* Размер - 9000 октет
* Плюсы:
  * Меньшую долю передаваемой информации занимают заголовки
  * Быстрее обрабатываем, так как не надо собирать пакеты воедино
* Минусы:
  * Увеличение задержек
  * Нужно авто определение MTU (Maximum transmission unit, максимальный размер передаваемого сообщения)
  * Нужно учитывать альтернативные пути
  * Неэффективность коммутаторов (старое оборудование) 
